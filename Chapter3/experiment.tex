\section{Experimental Setup}
\label{sec:experiment}
\subsection{Learning Module}
We use Support Vector Machines (SVMs) to predict the $V_t$ and $size$ of the netlist. For each gate in the netlist we compute the features mentioned in Section~\ref{sec:proposed}.
We use \emph{liblinearmulticore} package \cite{liblinear}, an open-sourced multi-threaded SVM implementation. It is an extension of libSVM \cite{libsvm} package and it can implement 11 different SVM models. We selected the \emph{L2Regularized logistic regression} model. The output of the SVM engine is the class label followed by class probability. We have a cascaded SVM  consisting of 2-stages for identifying $V_t$. The first stage identifies if it is an $HV_t$ or not. If it is not an $HV_t$ cell then we give it as an input to the second stage. We have a cascaded SVM consisting of 4-stages for identifying the size of the gate. The library has $10$ gate choices and we label the choices from 0-9. The initial SVM identifies if it is $size$ $0$ or not. If it is not the datapoint is fed to the subsequent stage. We decide if a datapoint belongs to a particular class or not by observing the class probabilities. If the class probability is less than the threshold then we label it as an \emph{unsure} datapoint and we initialize it to $HV_t$ and $size = 0$. The output of the SVM is passed to the delay recovery and power recovery modules.

\subsection{Delay and Power recovery}
The delay and power recovery stages are written in C++ and compiled using g++-4.8 . The netlist is represented as a graph using the \textit{Boost Graph Library version 1.53.0}. Each node in the graph has the following properties: 
%\begin{itemize}
i) node id,  ii) node type: a node can be either an input node or  an output node or one of the thirteen Boolean functions implemented in the ISPD contest library, iii)node slack, iv) arrival time, v) output capacitance, vi) fanouts, vii) fanins, viii) $V_t$, ix) $size$,  x) if the classifier is not able to predict the $V_t$ or $size$ properly then the gate is marked as unsure, xi) leakage, and; xii) critical : A node is marked critical if it has timing violations or if it cannot be optimized further that is, it has been assigned lowest $V_t$ and highest $size$ during the delay recovery phase or it has been assigned highest $V_t$ and smallest $size$ during the leakage power optimization phase.
%\end{itemize}

The values of delay and leakage power are assigned to each node, based on the $V_t$ and $size$. We use the timing engine in \cite{OpenTimer} for Static Timing Analysis which has  options for performing both full and incremental static timing analysis. We use the full STA option for our experiments. 

We use ISPD 2012 \cite{ispd:12} benchmarks and the ShaktiC core for our experimental setup. ShaktiC is a 64-bit in-order six stage pipeline processor running Linux version $4.13$. The processor implements the RISC-V microarchitecture. The processor incorporates several architectural features such as single and double precision serialized floating point units, a branch predictor unit, a restoring  multiplier, a restoring divider, instruction and data caches for improving the performance and area. The library is split into two versions i) a mixed cell library containing all the gate choices ii) a performance based library containing only the fast gate choices (all the low $V_t$ cells). The target delay for the design is obtained at $660Mhz$ by synthesizing the netlist with the $LV_t$ library. The resulting high performance netlist is then given as an input to our tool, our implementation of \cite{hu:12} and the commercial synthesis tool for leakage power optimization. The design contains $174,756$ combinational cells and $12,301$ sequential cells. We ran the experiments on a 4-core Xeon-E3120 server class machine with 32GB of memory. The \textit{MLTimer} tool is written in C++ and is compiled using g++-4.8.
